###############################################################################
#                                                                             #
#                           Fishing Out Nutrients                             #
#                 Predictive Models for Nutrient Compositions                 #
#                                                                             #
###############################################################################




# We collected a notable amount of data from 2 datasets, Hicks et al. 2019 (https://github.com/mamacneil/GlobalFishNutrients) and Lucas et al. 2016 (https://doi.org/10.6084/m9.figshare.c.3304116.v1), which we do not have permission to reprint the data from. Therefore, we cannot provide the raw data used for some of the analysis detailed below. We do, however, list all of the sources from which we obtained data in Supplementary Data 1. We include all of the code used to generate our model and data for analysis below for transparency and reproducibility.



#### NECESSARY PACKAGES ####

library(tidyverse)
library(data.table)
library(ggplot2)
library(GGally)
library(nlme)
library (MuMIn)
library(ggpubr)
library(mvtnorm)

#### PREDICTIVE MODELS FOR NUTRIENT COMPOSITION ####

# We present the  following function to demonstrate the basis of how we generated the linear mixed-effects models used to predict nutrient ratios in our study. We generated a model for each nutrient ratio (C:N, C:P, N:P) according to its corresponding nutrients (e.g., C:N from observed N).

ratio_model <- function(data, ratio = NULL, nutrient = NULL) {
  
  ctrl <- lmeControl(opt = "optim", maxIter = 2000, msMaxIter = 2000, msMaxEval = 2000) # Model control values
  
  # Construct the formula. Nutrient ratios were log-transformed to normalize values.
  formula <- as.formula(paste("log(", ratio, ") ~", nutrient, "* V.I."))
  random_formula <- as.formula(paste("~ 1 +", nutrient, "| family/genus"))
  
  # Fit the model
  model <- lme(formula, 
               random = random_formula,
               method = "REML", 
               data = data, 
               na.action = na.exclude, 
               control = ctrl)
  
  print(model)
  
  return(model)
}


##### Models Generated and Used in this Study #####

# We ran models using observed nutrient values that were both on a wet-weight and dry-weight basis. This meant potentially generating two models per nutrient. For example, one model predicting N:P from wet-based N values and another predicting N:P from dry-based N values. All of the code used to generate our models are reproduced below. All models used can also be accessed through the GitHub repository under "nutrient_ratio_models.RData". 

# # After the model was generated, we generated predicted nutrient ratios based on observed nutrient compositions and the random effects generated by our model. The code has been reproduced here along with each model.

# All observed nutrient ratio values were log-transformed prior to being used in the models.

# Sets model control values.
ctrl <- lmeControl(opt = "optim", maxIter = 2000, msMaxIter = 2000, msMaxEval = 2000)

# Models all followed the following naming conventions:


##### N:P from P Content #####

###### N:P from Wet P ######

W_ME_NP_P <- lme(log_N_P ~ WetWeight_Pwhole * V.I.,
                   random = ~ 1 + WetWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(W_ME_NP_P)
summary(W_ME_NP_P)
# Variation explained by the fixed effects (R2 fixed): 0.85
# Variation explained by the full model (R2 total): 0.96

# Extracts fixed effect coefficients from model
fixed_cf <- W_ME_NP_P$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(W_ME_NP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(W_ME_NP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "WetWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(W_ME_NP_P)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(W_ME_NP_P, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(W_ME_NP_P, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  

# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)



# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromWetP = NA
pred_Ratios$pred_log_NP_fromWetP = NA

# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}} 
  
  # Replicates the model formula to 
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$WetWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$WetWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.1096825) # The SD seen in this last addition is the standard deviation of the model residual which was manually input from the model summary.
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromWetP[J] = mean(pred_temp) 
  pred_Ratios$pred_log_NP_fromWetP[J] = sd(pred_temp)
}





###### N:P from Dry P ######

D_ME_NP_P <- lme(log_N_P ~ DryWeight_Pwhole * V.I.,
                   random = ~ 1 + DryWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_NP_P)
summary(D_ME_NP_P)
# Variation explained by the fixed effects (R2 fixed): 0.81
# Variation explained by the full model (R2 total): 0.96

# Extracts fixed effect coefficients from model
fixed_cf <- D_ME_NP_P$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_NP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_NP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_NP_P)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(D_ME_NP_P, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_NP_P, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  

# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromDryP = NA
pred_Ratios$predNP_fromDryP_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.09228913) # The SD seen in this last addition is the standard deviation of the model residual which was manually input from the model summary.
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromDryP[J] = mean(pred_temp)
  pred_Ratios$predNP_fromDryP_SD[J] = sd(pred_temp)
}





##### N:P from N Content #####

###### N:P from Wet N ###### 

W_ME_NP_N <- lme(log_N_P ~ WetWeight_N * V.I.,
                   random = ~ 1 + WetWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

summary(W_ME_NP_N)
r.squaredGLMM(W_ME_NP_N)
# Variation explained by the fixed effects (R2 fixed): 0.20
# Variation explained by the full model (R2 total): 0.75

# Extracts fixed effect coefficients from model
fixed_cf <- W_ME_NP_N$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(W_ME_NP_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(W_ME_NP_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "WetWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(W_ME_NP_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(W_ME_NP_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(W_ME_NP_N, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromWetN = NA
pred_Ratios$predNP_fromWetN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$WetWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$WetWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.26526403) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromWetN[J] = mean(pred_temp)
  pred_Ratios$pred_log_NP_fromWetN_SD[J] = sd(pred_temp)
}







###### N:P from Dry N ######

D_ME_NP_N <- lme(log_N_P ~ DryWeight_N * V.I.,
                   random = ~ 1 + DryWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_NP_N)
summary(D_ME_NP_N)
# Variation explained by the fixed effects (R2 fixed): 0.22
# Variation explained by the full model (R2 total): 0.88


# Extracts fixed effect coefficients from model
fixed_cf <- D_ME_NP_N$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_NP_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_NP_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_NP_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_NP_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_NP_N, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromDryN = NA
pred_Ratios$pred_log_NP_fromDryN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.17470338) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromDryN[J] = mean(pred_temp)
  pred_Ratios$pred_log_NP_fromDryN_SD[J] = sd(pred_temp)
}





##### C:N from N Content #####

###### C:N from Wet N #####

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:N from Dry N #####

D_ME_CN_N <- lme(log_C_N ~ DryWeight_N * V.I.,
                   random = ~ 1 + DryWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CN_N)
summary(D_ME_CN_N)
# Variation explained by the fixed effects (R2 fixed): 0.36
# Variation explained by the full model (R2 total): 0.93


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CN_N$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CN_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CN_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CN_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_CN_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_CN_N, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CN_fromDryN = NA
pred_Ratios$pred_log_CN_fromDryN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.05515624) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CN_fromDryN[J] = mean(pred_temp)
  pred_Ratios$pred_log_CN_fromDryN_SD[J] = sd(pred_temp)
}





##### C:N from C Content #####

###### C:N from Wet C ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:N from Dry C ######

D_ME_CN_C <- lme(log_C_N ~ DryWeight_C * V.I.,
                   random = ~ 1 + DryWeight_C | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CN_C)
summary(D_ME_CN_C)
# Variation explained by the fixed effects (R2 fixed): 0.45
# Variation explained by the full model (R2 total): 0.90


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CN_C$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CN_C)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CN_C)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_C")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CN_C)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_CN_C, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_CN_C, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CN_fromDryC = NA
pred_Ratios$pred_log_CN_fromDryC_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_C[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_C[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.068080943) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CN_fromDryC[J] = mean(pred_temp)
  pred_Ratios$pred_log_CN_fromDryC_SD[J] = sd(pred_temp)
}





##### C:P from P Content #####

###### C:P from Wet P ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:P from Dry P ######

D_ME_CP_P <- lme(log_C_P ~ DryWeight_Pwhole * V.I.,
                   random = ~ 1 + DryWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CP_P)
summary(D_ME_CP_P)
# Variation explained by the fixed effects (R2 fixed): 0.91
# Variation explained by the full model (R2 total): 0.98


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CP_P$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CP_P)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- c(1.107801e-04, 1.033576e-08, 0)
SD_Cor_fam <- c(0.35758034, 0.09762285, -1)


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CP_fromDryP = NA
pred_Ratios$pred_log_CP_fromDryP_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 6.485351e-02) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CP_fromDryP[J] = mean(pred_temp)
  pred_Ratios$pred_log_CP_fromDryP_SD[J] = sd(pred_temp)
}





##### C:P from C Content #####

###### C:P from Wet C ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:P from Dry C ######

D_ME_CP_C <- lme(log_C_P ~ DryWeight_C * V.I.,
                   random = ~ 1 + DryWeight_C | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CP_C)
summary(D_ME_CP_C)
# Variation explained by the fixed effects (R2 fixed): 0.86
# Variation explained by the full model (R2 total): 0.91


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CP_C$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CP_C)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CP_C)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_C")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CP_C)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- c(1.473225e-05, 1.429244e-03, -0.592)
SD_Cor_fam <- c(0.47397492, 0.01268809, -0.996)


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CP_fromDryC = NA
pred_Ratios$pred_log_CP_fromDryC_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_C[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + (fixed_cf[4] * pred_Ratios$DryWeight_C[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 1.393499e-01) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CP_fromDryC[J] = mean(pred_temp)
  pred_Ratios$pred_log_CP_fromDryC_SD[J] = sd(pred_temp)
}





#### NUTRIENT COMPOSITION PREDICTIONS FROM PREDICTED RATIOS ####

# Using the predicted nutrient ratios, we used the following code to predict missing nutrient values from observed nutrient compositions.

# Based on the R2 values for the models produced above, we followed the following order for estimating nutrient composition values.

## Estimating C
# 1 = Estimate C values using the predicted nutrient ratios from the C:P from dry P model (D_ME_CP_P)
# 2 = Estimate C values using the predicted nutrient ratios from the C:N from dry N model (D_ME_CN_N)


## Estimating N
# 1 = Estimate N values using the predicted nutrient ratios from the N:P from wet P model (W_ME_NP_P)
# 2 = Estimate N values using the predicted nutrient ratios from the N:P from dry P model (D_ME_NP_P)
# 3 = Estimate N values using the predicted nutrient ratios from the C:N from dry C model (D_ME_CN_C)

## Estimating P
# 1 = Estimate P values using the predicted nutrient ratios from the C:P from dry C model (D_ME_CP_C)
# 2 = Estimate P values using the predicted nutrient ratios from the N:P from dry N model (D_ME_NP_N)
# 3 = Estimate P values using the predicted nutrient ratios from the N:P from wet N model (W_ME_NP_N)



##### Deriving C from Predicted Nutrient Ratios #####

# Created a copy of the predicted ratios data frame (pred_Ratios) to generate the estimates of nutrient compositions.
pred_Ratios_NutrientContent <- pred_Ratios

# Generated the columns to be populated with estimates of both dry- and wet-based C composition values.
pred_Ratios_NutrientContent$derived_WetC <- NA
pred_Ratios_NutrientContent$derived_WetC_SD <- NA
pred_Ratios_NutrientContent$derived_DryC <- NA
pred_Ratios_NutrientContent$derived_DryC_SD <- NA

# For loop to generate predicted C composition values based on predicted nutrient ratio values.
for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  # This `ifelse` bracket tells the for loop to, for row X, preferentially use the predicted C:P ratio values from the D_ME_CP_P model and then use the predicted C:N values from D_ME_CN_N model.
  if (!is.na(pred_Ratios_NutrientContent$pred_log_CP_fromDryP[X])){
    
    # The following generates a random distribution of 10,000 predicted C:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = (exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CP_fromDryP[X], 
                         sd = pred_Ratios_NutrientContent$pred_log_CP_fromDryP_SD[X])) * (12/31))
    
    # Generates a distribution of predicted wet-weight C values based on observed wet-weight P values and predicted C:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated wet-weight C value with associated standard deviation.
    pred_Ratios_NutrientContent$derived_WetC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetC_SD[X] = sd(pred_temp)
    
    # Generates a distribution of predicted dry-weight C values based on observed dry-weight P values and predicted C:P ratio from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated dry-weight C value with associated standard deviation.
    pred_Ratios_NutrientContent$derived_DryC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryC_SD[X] = sd(pred_temp)
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_CN_fromDryN[X])) {
    
    # The following generates a random distribution of 10,000 predicted C:N values.
    pred_NR = (exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CN_fromDryN[X], 
                         sd = pred_Ratios_NutrientContent$pred_log_CN_fromDryN_SD[X])) * (12/14))
    
    # Generates a distribution of predicted wet-weight C values based on observed wet-weight N values and predicted C:N ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * pred_NR)
    
    # Obtains mean estimated wet-weight C value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_WetC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetC_SD[X] = sd(pred_temp)
    
    # Generates a distribution of predicted wet-weight C values based on observed dry-weight N values and predicted C:N ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * pred_NR)
    
    # Obtains mean estimated C dry-weight value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_DryC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryC_SD[X] = sd(pred_temp)
  }
    # If there was no predicted nutrient ratio value to use for row X, then the output here would simply be NA.
    else {NA}
  }} 







##### Deriving N from Predicted Nutrient Ratios #####

# Generated the columns to be populated with estimates of both dry- and wet-based N composition values.
pred_Ratios_NutrientContent$derived_WetN <- NA
pred_Ratios_NutrientContent$derived_WetN_SD <- NA
pred_Ratios_NutrientContent$derived_DryN <- NA
pred_Ratios_NutrientContent$derived_DryN_SD <- NA

# For loop to generate predicted N composition values based on predicted nutrient ratio values.
for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  # This `ifelse` bracket tells the for loop to, for row X, first use predicted N:P ratio values from the W_ME_NP_P model. If N:P values are not available through that model, then the for loop uses the predicted N:P values from D_ME_NP_P model. And finally, if neither of the two previous models produced values, then the for loop uses predicted C:N ratio values from the D_ME_CN_C model. 
  if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromWetP[X])){
    
    # The following generates a random distribution of 10,000 predicted N:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromWetP[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromWetP_SD[X])) * (14/31)
    
    # Generates a distribution of predicted wet-weight N values based on observed wet-weight P values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated wet-weight N value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
    
    # Generates a distribution of predicted wet-weight N values based on observed dry-weight P values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated dry-weight N value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromDryP[X])) {
    # The following generates a random distribution of 10,000 predicted N:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromDryP[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromDryP_SD[X])) * (14/31)
    
    # Generates a distribution of predicted wet-weight N values based on observed wet-weight P values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated wet-weight N value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
    
    # Generates a distribution of predicted wet-weight N values based on observed dry-weight P values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    # Obtains mean estimated dry-weight N value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
    
  }
    else { if (!is.na(pred_Ratios_NutrientContent$pred_log_CN_fromDryC[X])) {
      
      # The following generates a random distribution of 10,000 predicted C:N values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
      pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CN_fromDryC[X],
                          sd = pred_Ratios_NutrientContent$pred_log_CN_fromDryC_SD[X]))
      
      # Generates a distribution of predicted wet-weight N values based on observed wet-weight C values and predicted C:N ratios from the corresponding model.
      pred_temp = ((pred_Ratios_NutrientContent$WetWeight_C[X] * (14/12)) / pred_NR)
      
      # Obtains mean estimated wet-weight N value with associated standard deviation from the generated distribution.
      pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
      
      # Generates a distribution of predicted dry-weight N values based on observed dry-weight C values and predicted C:N ratios from the corresponding model.
      pred_temp = ((pred_Ratios_NutrientContent$DryWeight_C[X] * (14/12)) / pred_NR)
      
      # Obtains mean estimated dry-weight N value with associated standard deviation from the generated distribution.
      pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
    }
      # If there was no predicted nutrient ratio value to use for row X, then the output here would simply be NA.
      else {NA}
    }}}





##### Deriving P from Predicted Nutrient Ratios #####

# Generated the columns to be populated with estimates of both dry- and wet-based P composition values.
pred_Ratios_NutrientContent$derived_WetP <- NA
pred_Ratios_NutrientContent$derived_WetP_SD <- NA
pred_Ratios_NutrientContent$derived_WetP_SD_logit <- NA
pred_Ratios_NutrientContent$derived_DryP <- NA
pred_Ratios_NutrientContent$derived_DryP_SD <- NA
pred_Ratios_NutrientContent$derived_DryP_SD_logit <- NA


for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  # This `ifelse` bracket tells the for loop to, for row X, first use predicted C:P ratio values from the D_ME_CP_C model. If C:P values are not available through that model, then the for loop uses the predicted N:P values from the D_ME_NP_N model. And finally, if neither of the two previous models produced values, then the for loop uses predicted N:P ratio values from the W_ME_NP_N model. 
  if (!is.na(pred_Ratios_NutrientContent$pred_log_CP_fromDryC[X])){
    
    # The following generates a random distribution of 10,000 predicted C:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CP_fromDryC[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_CP_fromDryC_SD[X]))
    
    # Generates a distribution of predicted wet-weight P values based on observed wet-weight C values and predicted C:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_C[X] * (31/12)) / pred_NR
    
    # Obtains mean estimated wet-weight P value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
    
    # Generates a distribution of predicted wet-weight P values based on observed dry-weight C values and predicted C:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_C[X] * (31/12)) / pred_NR
    
    # Obtains mean estimated dry-weight P value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromDryN[X])) {
    
    # The following generates a random distribution of 10,000 predicted N:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromDryN[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromDryN_SD[X]))
    
    # Generates a distribution of predicted wet-weight P values based on observed wet-weight N values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * (31/14)) / pred_NR
    
    # Obtains mean estimated wet-weight P value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
    
    # Generates a distribution of predicted dry-weight P values based on observed dry-weight N values and predicted N:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * (31/14)) / pred_NR
    
    # Obtains mean estimated dry-weight P value with associated standard deviation from the generated distribution.
    pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
    
  }
    else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromWetN[X])) {
      
      # The following generates a random distribution of 10,000 predicted N:P values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
      pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromWetN[X],
                          sd = pred_Ratios_NutrientContent$pred_log_NP_fromWetN_SD[X]))
      
      # Generates a distribution of predicted wet-weight P values based on observed wet-weight N values and predicted N:P ratios from the corresponding model.
      pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * (31/14)) / pred_NR
      
      # Obtains mean estimated wet-weight P value with associated standard deviation from the generated distribution.
      pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
      
      # Generates a distribution of predicted dry-weight P values based on observed dry-weight N values and predicted N:P ratios from the corresponding model.
      pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * (31/14)) / pred_NR
      
      # Obtains mean estimated dry-weight P value with associated standard deviation from the generated distribution.
      pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
    }
      # If there was no predicted nutrient ratio value to use for row X, then the output here would simply be NA.
      else {NA}
    }}}


#### MERGING OBSERVED AND PREDICTED NUTRIENT DATA ####

# After all possible nutrient composition predictions had been generated, we ran the following code for each taxa to preferentially select observed nutrient compositions and only use the predicted compositions if an observed value was not available. 

# NOTE: For observed values, we did not record SDs since these were not always reported. However, to account for uncertainty in observed nutrient values, we assigned SDs based on the in-species coefficients of variation (CV) for each nutrient observed in Czamanski et al. (2011) (https://link.springer.com/article/10.1007/s00227-011-1783-7). The coefficients of variation for each nutrient were as follows: CV of C = 0.0175, CV of N = 0.0097, and CV of P = 0.0528. This assured that each observed and predicted value had an associated SD to be used in later calculations.

# Filter out unnecessary columns.
Observed_and_Predicted_NutrientContent <- pred_Ratios_NutrientContent[ , c(1:17, 42:53)]

##### Merging Observed and Derived C #####

# The code below is to combine observed and predicted C composition values into one column.

Observed_and_Predicted_NutrientContent <- Observed_and_Predicted_NutrientContent %>% 
  # Selects for observed C value first, if available. Otherwise, it selects for the predicted (derived) C value, if available.
  mutate(combined_WetWeightC = as.numeric(ifelse(!is.na(WetWeight_C), paste(WetWeight_C),
                                                 paste(derived_WetC)))) %>% 
  mutate(combined_WetWeight_C_SD = as.numeric(ifelse(!is.na(WetWeight_C),  WetWeight_C * 0.0175,
                                                     paste(derived_WetC_SD)))) %>% 
  mutate(combined_DryWeightC = as.numeric(ifelse(!is.na(DryWeight_C), paste(DryWeight_C),
                                                 paste(derived_DryC)))) %>% 
  mutate(combined_DryWeight_C_SD = as.numeric(ifelse(!is.na(DryWeight_C), DryWeight_C * 0.0175,
                                                     paste(derived_DryC_SD))))





##### Merging Observed and Derived N #####

# The code below is to combine observed and predicted N composition values into one column.

Observed_and_Predicted_NutrientContent <- Observed_and_Predicted_NutrientContent %>%
  # Selects for observed N value first, if available. Otherwise, it selects for the predicted (derived) N value, if available.
  mutate(combined_WetWeightN = as.numeric(ifelse(!is.na(WetWeight_N), paste(WetWeight_N),
                                                 paste(derived_WetN)))) %>% 
  mutate(combined_WetWeight_N_SD = as.numeric(ifelse(!is.na(WetWeight_N),  WetWeight_N * 0.0097,
                                                     paste(derived_WetN_SD)))) %>% 
  mutate(combined_DryWeightN = as.numeric(ifelse(!is.na(DryWeight_N), paste(DryWeight_N),
                                                 paste(derived_DryN)))) %>% 
  mutate(combined_DryWeight_N_SD = as.numeric(ifelse(!is.na(DryWeight_N), DryWeight_N * 0.0097,
                                                     paste(derived_DryN_SD))))






##### Merging Observed and Derived P #####

# The code below is to combine observed and predicted P composition values into one column.

Observed_and_Predicted_NutrientContent <- Observed_and_Predicted_NutrientContent %>% 
  # Selects for observed P value first, if available. Otherwise, it selects for the predicted (derived) P value, if available.
  mutate(combined_WetWeightP = as.numeric(ifelse(!is.na(WetWeight_Pwhole), paste(WetWeight_Pwhole),
                                                 paste(derived_WetP)))) %>% 
  mutate(combined_WetWeight_P_SD = as.numeric(ifelse(!is.na(WetWeight_Pwhole),  WetWeight_Pwhole * 0.0528,
                                                     paste(derived_WetP_SD)))) %>% 
  mutate(combined_DryWeightP = as.numeric(ifelse(!is.na(DryWeight_Pwhole), paste(DryWeight_Pwhole),
                                                 paste(derived_DryP)))) %>% 
  mutate(combined_DryWeight_P_SD = as.numeric(ifelse(!is.na(DryWeight_Pwhole), DryWeight_Pwhole * 0.0528,
                                                     paste(derived_DryP_SD))))







