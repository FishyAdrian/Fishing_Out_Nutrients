###############################################################################
#                                                                             #
#                           Fishing Out Nutrients                             #
#                             Data Analyses Code                              #
#                                                                             #
###############################################################################




# We collected a notable amount of data from 2 datasets, Hicks et al. 2019 (https://github.com/mamacneil/GlobalFishNutrients) and Lucas et al. 2016 (https://doi.org/10.6084/m9.figshare.c.3304116.v1), which we do not have permission to reprint the data from. Therefore, we cannot provide the raw data used for some of the analysis detailed below. We do, however, list all of the sources from which we obtained data in Supplementary Data 1. We include all of the code used to generate our model and data for analysis below for transparency and reproducibility.



#### NECESSARY PACKAGES ####
library(tidyverse)
library(data.table)
library(ggplot2)
library(GGally)
library(nlme)
library (MuMIn)
library(ggpubr)
library(mvtnorm)

#### PREDICTIVE MODELS FOR NUTRIENT COMPOSITION ####

# We present the  following function to demonstrate the basis of how we generated the linear mixed-effects models used to predict nutrient ratios in our study. We generated a model for each nutrient ratio (C:N, C:P, N:P) according to its corresponding nutrients (e.g., C:N from observed N).

ratio_model <- function(data, ratio = NULL, nutrient = NULL) {
  
  ctrl <- lmeControl(opt = "optim", maxIter = 2000, msMaxIter = 2000, msMaxEval = 2000) # Model control values
  
  # Construct the formula. Nutrient ratios were log-transformed to normalize values.
  formula <- as.formula(paste("log(", ratio, ") ~", nutrient, "* V.I."))
  random_formula <- as.formula(paste("~ 1 +", nutrient, "| family/genus"))
  
  # Fit the model
  model <- lme(formula, 
               random = random_formula,
               method = "REML", 
               data = data, 
               na.action = na.exclude, 
               control = ctrl)
  
  print(model)
  
  return(model)
}


##### Models Generated and Used in this Study #####

# We ran models using observed nutrient values that were both on a wet-weight and dry-weight basis. This meant potentially generating two models per nutrient. For example, one model predicting N:P from wet-based N values and another predicting N:P from dry-based N values. All of the code used to generate our models are reproduced below. All models used can also be accessed through the GitHub repository under "nutrient_ratio_models.RData". 

# # After the model was generated, we generated predicted nutrient ratios based on observed nutrient compositions and the random effects generated by our model. The code has been reproduced here along with each model.

# All observed nutrient ratio values were log-transformed prior to being used in the models.

# Sets model control values.
ctrl <- lmeControl(opt = "optim", maxIter = 2000, msMaxIter = 2000, msMaxEval = 2000)

# Models all followed the following naming conventions:


##### N:P from P Content #####

###### N:P from Wet P ######

W_ME_NP_P <- lme(log_N_P ~ WetWeight_Pwhole * V.I.,
                   random = ~ 1 + WetWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(W_ME_NP_P)
summary(W_ME_NP_P)
# Variation explained by the fixed effects (R2 fixed): 0.85
# Variation explained by the full model (R2 total): 0.96

# Extracts fixed effect coefficients from model
fixed_cf <- W_ME_NP_P$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(W_ME_NP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(W_ME_NP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "WetWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(W_ME_NP_P)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(W_ME_NP_P, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(W_ME_NP_P, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  

# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)



# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromWetP = NA
pred_Ratios$pred_log_NP_fromWetP = NA

# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}} 
  
  # Replicates the model formula to 
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$WetWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$WetWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.1096825) # The SD seen in this last addition is the standard deviation of the model residual which was manually input from the model summary.
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromWetP[J] = mean(pred_temp) 
  pred_Ratios$pred_log_NP_fromWetP[J] = sd(pred_temp)
}





###### N:P from Dry P ######

D_ME_NP_P <- lme(log_N_P ~ DryWeight_Pwhole * V.I.,
                   random = ~ 1 + DryWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_NP_P)
summary(D_ME_NP_P)
# Variation explained by the fixed effects (R2 fixed): 0.81
# Variation explained by the full model (R2 total): 0.96

# Extracts fixed effect coefficients from model
fixed_cf <- D_ME_NP_P$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_NP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_NP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_NP_P)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(D_ME_NP_P, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_NP_P, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  

# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromDryP = NA
pred_Ratios$predNP_fromDryP_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.09228913) # The SD seen in this last addition is the standard deviation of the model residual which was manually input from the model summary.
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromDryP[J] = mean(pred_temp)
  pred_Ratios$predNP_fromDryP_SD[J] = sd(pred_temp)
}





##### N:P from N Content #####

###### N:P from Wet N ###### 

W_ME_NP_N <- lme(log_N_P ~ WetWeight_N * V.I.,
                   random = ~ 1 + WetWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

summary(W_ME_NP_N)
r.squaredGLMM(W_ME_NP_N)
# Variation explained by the fixed effects (R2 fixed): 0.20
# Variation explained by the full model (R2 total): 0.75

# Extracts fixed effect coefficients from model
fixed_cf <- W_ME_NP_N$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(W_ME_NP_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(W_ME_NP_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "WetWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(W_ME_NP_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects
SD_Cor_genus <- intervals(W_ME_NP_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(W_ME_NP_N, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)  


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromWetN = NA
pred_Ratios$predNP_fromWetN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$WetWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$WetWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.26526403) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromWetN[J] = mean(pred_temp)
  pred_Ratios$pred_log_NP_fromWetN_SD[J] = sd(pred_temp)
}







###### N:P from Dry N ######

D_ME_NP_N <- lme(log_N_P ~ DryWeight_N * V.I.,
                   random = ~ 1 + DryWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_NP_N)
summary(D_ME_NP_N)
# Variation explained by the fixed effects (R2 fixed): 0.22
# Variation explained by the full model (R2 total): 0.88


# Extracts fixed effect coefficients from model
fixed_cf <- D_ME_NP_N$coefficients$fixed

# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_NP_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_NP_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_NP_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_NP_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_NP_N, level = 0.95, which = "all")$reStruct$family[ , 2]

# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_NP_fromDryN = NA
pred_Ratios$pred_log_NP_fromDryN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.17470338) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_NP_fromDryN[J] = mean(pred_temp)
  pred_Ratios$pred_log_NP_fromDryN_SD[J] = sd(pred_temp)
}





##### C:N from N Content #####

###### C:N from Wet N #####

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:N from Dry N #####

D_ME_CN_N <- lme(log_C_N ~ DryWeight_N * V.I.,
                   random = ~ 1 + DryWeight_N | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CN_N)
summary(D_ME_CN_N)
# Variation explained by the fixed effects (R2 fixed): 0.36
# Variation explained by the full model (R2 total): 0.93


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CN_N$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CN_N)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CN_N)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_N")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CN_N)$family

# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_CN_N, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_CN_N, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CN_fromDryN = NA
pred_Ratios$pred_log_CN_fromDryN_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_N[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_N[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.05515624) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CN_fromDryN[J] = mean(pred_temp)
  pred_Ratios$pred_log_CN_fromDryN_SD[J] = sd(pred_temp)
}





##### C:N from C Content #####

###### C:N from Wet C ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:N from Dry C ######

D_ME_CN_C <- lme(log_C_N ~ DryWeight_C * V.I.,
                   random = ~ 1 + DryWeight_C | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CN_C)
summary(D_ME_CN_C)
# Variation explained by the fixed effects (R2 fixed): 0.45
# Variation explained by the full model (R2 total): 0.90


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CN_C$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CN_C)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CN_C)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_C")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CN_C)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- intervals(D_ME_CN_C, level = 0.95, which = "all")$reStruct$genus[ , 2]
SD_Cor_fam <- intervals(D_ME_CN_C, level = 0.95, which = "all")$reStruct$family[ , 2]


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CN_fromDryC = NA
pred_Ratios$pred_log_CN_fromDryC_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_C[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_C[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 0.068080943) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CN_fromDryC[J] = mean(pred_temp)
  pred_Ratios$pred_log_CN_fromDryC_SD[J] = sd(pred_temp)
}





##### C:P from P Content #####

###### C:P from Wet P ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:P from Dry P ######

D_ME_CP_P <- lme(log_C_P ~ DryWeight_Pwhole * V.I.,
                   random = ~ 1 + DryWeight_Pwhole | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CP_P)
summary(D_ME_CP_P)
# Variation explained by the fixed effects (R2 fixed): 0.91
# Variation explained by the full model (R2 total): 0.98


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CP_P$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CP_P)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CP_P)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_Pwhole")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CP_P)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- c(1.107801e-04, 1.033576e-08, 0)
SD_Cor_fam <- c(0.35758034, 0.09762285, -1)


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CP_fromDryP = NA
pred_Ratios$pred_log_CP_fromDryP_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + 
    ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_Pwhole[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + 
    (fixed_cf[4] * pred_Ratios$DryWeight_Pwhole[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 6.485351e-02) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CP_fromDryP[J] = mean(pred_temp)
  pred_Ratios$pred_log_CP_fromDryP_SD[J] = sd(pred_temp)
}





##### C:P from C Content #####

###### C:P from Wet C ######

# These models were not generated because there was not a sufficient number of wet-weight C observations to parameterize the model.



###### C:P from Dry C ######

D_ME_CP_C <- lme(log_C_P ~ DryWeight_C * V.I.,
                   random = ~ 1 + DryWeight_C | family/genus,
                   method = "REML", data = Nutrient_Ratios[genus != "NA"], 
                   na.action=na.exclude, control = ctrl)

r.squaredGLMM(D_ME_CP_C)
summary(D_ME_CP_C)
# Variation explained by the fixed effects (R2 fixed): 0.86
# Variation explained by the full model (R2 total): 0.91


# Extracts fixed effect coefficients from model.
fixed_cf <- D_ME_CP_C$coefficients$fixed


# The code below joins the random effect values from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
genus_rf <- setDT(ranef(D_ME_CP_C)$genus, keep.rownames = "Genus")
family_rf <- setDT(ranef(D_ME_CP_C)$family, keep.rownames = "Family")
genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
genus_rf <- merge(genus_rf, family_rf[ , c("Family", "(Intercept)", "DryWeight_C")], by = ("Family"), all.x = T)
genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
genus_rf <- genus_rf[ , c(2, 7, 8)]
genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
family_rf <- ranef(D_ME_CP_C)$family


# This code extracts the SD for the intercept and slope (and the correlation between the two) for the random effects.
SD_Cor_genus <- c(1.473225e-05, 1.429244e-03, -0.592)
SD_Cor_fam <- c(0.47397492, 0.01268809, -0.996)


# This code produces the variance-covariance matrices for the corresponding model.
vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                    prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                  nrow = 2, ncol = 2, byrow = T)
vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                      prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                    nrow = 2, ncol = 2, byrow = T)


# This code produces a random normal distribution of 10,000 values of random effect values so that we can draw from these when making the predictions below. Essentially, this is to account for the observed variation across the random-effect groups (genus and family).
rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)


# The code below creates the necessary data columns that will then be filled in.
pred_Ratios$pred_log_CP_fromDryC = NA
pred_Ratios$pred_log_CP_fromDryC_SD = NA


# For loop to generate predicted nutrient ratios using the model's coefficients and random effects.
for (J in 1:nrow(pred_Ratios)) {
  # This `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (if that group had one). Otherwise, we pulled a random effect value from the simulated normal distribution of the random effects (rf_dist) which we generated above.
  if (pred_Ratios$genus[J] %in% rownames(genus_rf)) {
    rf_use = genus_rf[which(rownames(genus_rf) == pred_Ratios$genus[J]), ]
  }
  else{
    if (pred_Ratios$family[J] %in% rownames(family_rf)) {
      rf_use = family_rf[which(rownames(family_rf) == pred_Ratios$family[J]), ]
    }
    else{rf_use = rf_dist_fam + rf_dist_genus}}
  
  pred_temp <- (fixed_cf[1] + rf_use[, 1]) + ((fixed_cf[2] + rf_use[, 2]) * pred_Ratios$DryWeight_C[J]) + 
    (fixed_cf[3] * pred_Ratios$V.I.numeric[J]) + (fixed_cf[4] * pred_Ratios$DryWeight_C[J] * pred_Ratios$V.I.numeric[J]) + 
    rnorm(10000, 0, sd = 1.393499e-01) # the SD seen in this last addition is the standard deviation of the model residuals; had to be manually input from the model summary
  
  # This generates a predicted nutrient ratio based on the simulated distribution of values above (pred_temp).
  pred_Ratios$pred_log_CP_fromDryC[J] = mean(pred_temp)
  pred_Ratios$pred_log_CP_fromDryC_SD[J] = sd(pred_temp)
}





#### NUTRIENT COMPOSITION PREDICTIONS FROM PREDICTED RATIOS ####

# Using the predicted nutrient ratios, we used the following code to predict missing nutrient values from observed nutrient compositions.

# Based on the R2 values for the models produced above, we followed the following order for estimating nutrient composition values.

# 1 = Estimate C values using the predicted nutrient ratios from the C:P from dry P model (D_ME_CP_P)
# 2 = Estimate C values using the predicted nutrient ratios from the C:N from dry N model (D_ME_CN_N)
# 3 = Estimate N values using the predicted nutrient ratios from the N:P from wet P model (W_ME_NP_P)
# 4 = Estimate N values using the predicted nutrient ratios from the N:P from dry P model (D_ME_NP_P)
# 5 = Estimate N values using the predicted nutrient ratios from the C:N from dry C model (D_ME_CN_C)
# 6 = Estimate P values using the predicted nutrient ratios from the C:P from dry C model (D_ME_CP_C)
# 7 = Estimate P values using the predicted nutrient ratios from the N:P from dry N model (D_ME_NP_N)
# 8 = Estimate P values using the predicted nutrient ratios from the N:P from wet N model (W_ME_NP_N)



##### Deriving C from Predicted Nutrient Ratios #####

# Created a copy of the predicted ratios data frame (pred_Ratios) to generate the estimates of nutrient compositions.
pred_Ratios_NutrientContent <- pred_Ratios

# Generated the columns to be populated with estimates of both dry- and wet-based C composition values.
pred_Ratios_NutrientContent$derived_WetC <- NA
pred_Ratios_NutrientContent$derived_WetC_SD <- NA
pred_Ratios_NutrientContent$derived_DryC <- NA
pred_Ratios_NutrientContent$derived_DryC_SD <- NA

# For loop to generate predicted C composition values based on predicted nutrient ratio values.
for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  # This `ifelse` bracket tells the for loop to preferentially use the predicted C:P ratio values from D_ME_CP_P and then use the predicted C:N values from D_ME_CN_N.
  if (!is.na(pred_Ratios_NutrientContent$pred_log_CP_fromDryP[X])){
    
    # The following generates a random distribution of 10,000 C:P predicted values. This code takes the predicted values out of log-space and then transforms them to a molar basis.
    pred_NR = (exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CP_fromDryP[X], 
                         sd = pred_Ratios_NutrientContent$pred_log_CP_fromDryP_SD[X])) * (12/31))
    
    # Generates a distribution of predicted wet-weight C values based on observed values wet-weight P and predicted C:P ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_WetC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetC_SD[X] = sd(pred_temp)
    
    # Generates a distribution of predicted dry-weight C values based on observed values of dry-weight P and predicted C:P ratio from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_DryC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryC_SD[X] = sd(pred_temp)
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_CN_fromDryN[X])) {
    
    # Distribution of 10,000 predicted C:N values.
    pred_NR = (exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CN_fromDryN[X], 
                         sd = pred_Ratios_NutrientContent$pred_log_CN_fromDryN_SD[X])) * (12/14))
    
    # Generates a distribution of predicted wet-weight C values based on observed values wet-weight N and predicted C:N ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_WetC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetC_SD[X] = sd(pred_temp)
    
    # Generates a distribution of predicted wet-weight C values based on observed values dry-weight N and predicted C:N ratios from the corresponding model.
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_DryC[X] = mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryC_SD[X] = sd(pred_temp)
  }
    else {NA}
  }} 







##### Deriving N from Predicted Nutrient Ratios #####

# The for() loop below uses the refined predictions with the known standard deviations to derive the missing nutrient content data.

pred_Ratios_NutrientContent$derived_WetN <- NA
pred_Ratios_NutrientContent$derived_WetN_SD <- NA
pred_Ratios_NutrientContent$derived_WetN_SD_logit <- NA
pred_Ratios_NutrientContent$derived_DryN <- NA
pred_Ratios_NutrientContent$derived_DryN_SD <- NA
pred_Ratios_NutrientContent$derived_DryN_SD_logit <- NA

for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromWetP[X])){
    
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromWetP[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromWetP_SD[X])) * (14/31)
    
    # Wet Weight N
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD_logit[X] = sd(qlogis(pred_temp/100))
    
    # Dry Weight N
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD_logit[X] = sd(qlogis(pred_temp/100))
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromDryP[X])) {
    
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromDryP[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromDryP_SD[X])) * (14/31)
    
    # Wet Weight N
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_WetN_SD_logit[X] = sd(qlogis(pred_temp/100))
    
    # Dry Weight N
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_Pwhole[X] * pred_NR)
    
    pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_DryN_SD_logit[X] = sd(qlogis(pred_temp/100))
    
  }
    else { if (!is.na(pred_Ratios_NutrientContent$pred_log_CN_fromDryC[X])) {
      
      pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CN_fromDryC[X],
                          sd = pred_Ratios_NutrientContent$pred_log_CN_fromDryC_SD[X]))
      
      # Wet Weight N
      pred_temp = ((pred_Ratios_NutrientContent$WetWeight_C[X] * (14/12)) / pred_NR)
      
      pred_Ratios_NutrientContent$derived_WetN[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_WetN_SD[X] <- sd(pred_temp)
      pred_Ratios_NutrientContent$derived_WetN_SD_logit[X] = sd(qlogis(pred_temp/100))
      
      # Dry Weight N
      pred_temp = ((pred_Ratios_NutrientContent$DryWeight_C[X] * (14/12)) / pred_NR)
      
      pred_Ratios_NutrientContent$derived_DryN[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_DryN_SD[X] <- sd(pred_temp)
      pred_Ratios_NutrientContent$derived_DryN_SD_logit[X] = sd(qlogis(pred_temp/100))
    }
      else {NA}
    }}}





##### Deriving P from Predicted Nutrient Ratios #####

pred_Ratios_NutrientContent$derived_WetP <- NA
pred_Ratios_NutrientContent$derived_WetP_SD <- NA
pred_Ratios_NutrientContent$derived_WetP_SD_logit <- NA
pred_Ratios_NutrientContent$derived_DryP <- NA
pred_Ratios_NutrientContent$derived_DryP_SD <- NA
pred_Ratios_NutrientContent$derived_DryP_SD_logit <- NA


for (X in 1:nrow(pred_Ratios_NutrientContent)) {
  if (!is.na(pred_Ratios_NutrientContent$pred_log_CP_fromDryC[X])){
    
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_CP_fromDryC[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_CP_fromDryC_SD[X]))
    
    # Wet Weight P
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_C[X] * (31/12)) / pred_NR
    
    pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD_logit[X] <- sd(qlogis(pred_temp/100))
    
    # Dry Weight P
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_C[X] * (31/12)) / pred_NR
    
    pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD_logit[X] <- sd(qlogis(pred_temp/100))
    
  } 
  else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromDryN[X])) {
    
    pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromDryN[X], 
                        sd = pred_Ratios_NutrientContent$pred_log_NP_fromDryN_SD[X]))
    
    # Wet Weight P
    pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * (31/14)) / pred_NR
    
    pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_WetP_SD_logit[X] <- sd(qlogis(pred_temp/100))
    
    # Dry Weight P
    pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * (31/14)) / pred_NR
    
    pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
    pred_Ratios_NutrientContent$derived_DryP_SD_logit[X] <- sd(qlogis(pred_temp/100))
    
  }
    else { if (!is.na(pred_Ratios_NutrientContent$pred_log_NP_fromWetN[X])) {
      
      pred_NR = exp(rnorm(10000, mean = pred_Ratios_NutrientContent$pred_log_NP_fromWetN[X],
                          sd = pred_Ratios_NutrientContent$pred_log_NP_fromWetN_SD[X]))
      
      # Wet Weight P
      pred_temp = (pred_Ratios_NutrientContent$WetWeight_N[X] * (31/14)) / pred_NR
      
      pred_Ratios_NutrientContent$derived_WetP[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_WetP_SD[X] <- sd(pred_temp)
      pred_Ratios_NutrientContent$derived_WetP_SD_logit[X] <- sd(qlogis(pred_temp/100))
      
      # Dry Weight P
      pred_temp = (pred_Ratios_NutrientContent$DryWeight_N[X] * (31/14)) / pred_NR
      
      pred_Ratios_NutrientContent$derived_DryP[X] <- mean(pred_temp)
      pred_Ratios_NutrientContent$derived_DryP_SD[X] <- sd(pred_temp)
      pred_Ratios_NutrientContent$derived_DryP_SD_logit[X] <- sd(qlogis(pred_temp/100))
    }
      else {NA}
    }}}






#### NUTRIENT COMPOSITIONS FOR HIGHER-LEVEL GROUPS AND DATA-SPARSE SPECIES ####

# After we generated predicted nutrient compositions using the predicted ratios and simulations described above, we averaged our observed and predicted nutrient data at the species level to generate C, N, and P compositions. To reduce the influence of over-represented species in our calculations, we first calculated the mean and standard deviations of nutrient composition values for each species represented in our dataset. Then, for each taxonomic level above species, we calculated the mean and standard deviation of nutrient composition values based on each taxonomic level's corresponding species. To account for compounding uncertainty among our observed and predicted values, we calculated the compounded standard deviation as described by the compound_SD equation below. NOTE: For observed values, we did not record SDs since these were not always reported. However, to account for uncertainty in observed nutrient values, we assigned SDs based on the in-species coefficients of variation (CV) for each nutrient observed in Czamanski et al. (2011) (https://link.springer.com/article/10.1007/s00227-011-1783-7). The coefficients of variation for each nutrient were as follows: CV of C = 0.0175, CV of N = 0.0097, and CV of P = 0.0528. This assured that each observed and predicted value had an associated SD to be used in calculating the compound standard deviation.

# In the following function, data is used to designate the data frame that has all of your observed and predicted values. Level designates the taxonomic level you are attempting to average. Nutrient and "nutrient_SD" designates the columns that hold your nutrient values and their corresponding SDs, respectively.

nutrient_mean_SD <- function(data, level = NULL, nutrient = NULL, nutrient_SD = NULL) {
  
  level <- enquo(level)
  nutrient <- enquo(nutrient)
  nutrient_SD <- enquo(nutrient_SD)
  
  # Ensure that nutrient and nutrient_SD are provided
  if (is.null(level) || is.null(nutrient) || is.null(nutrient_SD)) {
    stop("Please specify level, nutrient, and nutrient_SD columns.")
  }
  
  mean_nutrient_df <- data %>% 
    group_by(!!level) %>% 
    summarise(mean_nutrient = mean(!!nutrient, na.rm = TRUE),
              # The following calculates the compound standard deviation across values for a nutrient.
              compound_SD = sqrt(sum((!!nutrient_SD^2 + 
                                        (!!nutrient - mean(!!nutrient, na.rm = TRUE))^2), 
                                     na.rm = TRUE) / n()),
              .groups = 'drop')
  
  return(mean_nutrient_df)
}



#### ASSIGNING NUTRIENT COMPOSITION VALUES FOR SPECIES AND GROUPS WITHOUT DATA ####

# Explanation here...

# Function to fill missing nutrient content based on taxonomic hierarchy
assign_nutrient_value <- function(data, taxonomic_levels, nutrient_col = NULL, sd_col = NULL) {
  
  for (i in 1:nrow(data)) {
    if (is.na(data[[nutrient_col]][i])) {
      for (level in taxonomic_levels) {
        taxon <- data[[level]][i]
        # Check if there is a non-NA nutrient value for the taxon in the same data frame
        matching_row <- data[!is.na(data[[nutrient_col]]) & data[[level]] == taxon, ]
        if (nrow(matching_row) > 0) {
          data[[nutrient_col]][i] <- matching_row[[nutrient_col]][1] # Assign the first matching value
          data[[sd_col]][i] <- matching_row[[sd_col]][1] # Assign the first matching SD value
          break
        }
      }
    }
  }
  
  return(data)
}
  

# You can assign the taxonomic levels you desire to draw averages from by assigning the levels to a vector like so:
taxonomic_levels <- c("genus", "family", "order", "super_order", "class", "super_class", "sub_phylum", "phylum")
  
  
  
  
  

#### ESTIMATING NUTRIENT EXTRACTIONS ####

# To account for uncertainties around producing nutrient extraction estimates, we generated 100 nutrient values drawn from a random normal distribution of each taxa's mean nutrient compositions for each row of the SAU dataset. The SAU data comprised 6.7+ million rows of data where each row of data had a distribution of 100 nutrient composition values for the row's corresponding taxa.

# We wanted to make sure we could generate distributions that were between 0 and 100. Since some of our values are very close to 0 (especially in the case of phosphorus), we wanted to ensure that no negative values were accidentally generated during our random draws. To accomplish this, we transformed our nutrient compositions into alpha and beta values so we could generate beta distributions. The transformations we made are recreated below.

taxa_nutrient.data <- taxa_nutrient.data %>% 
  mutate(alph_C = (mean_C/100)*(((mean_C/100)*(1- (mean_C/100)))/((SD_C/100)^2)-1),
         bet_C = (1-(mean_C/100))*(((mean_C/100)*(1- (mean_C/100)))/((SD_C/100)^2)-1),
         alph_N = (mean_N/100)*(((mean_N/100)*(1- (mean_N/100)))/((SD_N/100)^2)-1),
         bet_N = (1-(mean_N/100))*(((mean_N/100)*(1- (mean_N/100)))/((SD_N/100)^2)-1),
         alph_P = (mean_P/100)*(((mean_P/100)*(1- (mean_P/100)))/((SD_P/100)^2)-1),
         bet_P = (1-(mean_P/100))*(((mean_P/100)*(1- (mean_P/100)))/((SD_P/100)^2)-1))


# The following code created a vector of integers to identify which rows of the nutrient composition data frame had to be called when calculating nutrient extraction with the fisheries data frame. TaxonKey is a unique ID code for each taxa. These ID codes were provided by the SAU and used to match taxa between our nutrient composition data frame and the catch data frame.
taxaorder <- match(taxa_nutrient.data$TaxonKey, SAU_catch.data$TaxonKey)


# Then, using the newly transformed values, we generated 100 nutrient composition values taken from beta distributions. Here, we generated a matrix where each row of the fisheries dataset had a distribution of 100 nutrient values based on the corresponding taxa for each row. Each of the 100 generate values were then multiplied by the landed amount reported in the fisheries dataset. The code used to generate these matrices is reproduced below.

C_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_C[taxaorder], 
        taxa_nutrient.data$bet_C[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

N_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_N[taxaorder], 
        taxa_nutrient.data$bet_N[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

P_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_P[taxaorder], 
        taxa_nutrient.data$bet_P[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

# Then, we multiplied the matrix of the generated values by the landed amount (tonnes) to generate a distribution of 100 estimates of nutrient extractions. We used the Sea Around Us data (https://www.seaaroundus.org/data/) at the EEZ and High Seas level meaning we download the CSV data files for each EEZ (n=283) and High Seas region (n=18) and compiled all of the data into one data frame that comprised 6.7+ million records of landed catches (reported in tonnes in the SAU data).

C_extractions <- SAU_catch.data$tonnes * C_distributions
N_extractions <- SAU_catch.data$tonnes * N_distributions
P_extractions <- SAU_catch.data$tonnes * P_distributions


# Finally, we took C_extracted to be the mean of the 100 extraction estimates produced above. We also obtained the SD, IQR, and 95% CIs. The 'Fisheries_NutrientExtraction' represents our finalized data frame which had all the estimates of C, N, and P extraction per row of the fisheries record (n=)

# Carbon
Fisheries_NutrientExtraction$C_extracted <- apply(C_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$C_extracted_SD <- apply(C_extractions, 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$C_extracted_lowCI <- quantiles_CIs_C[1, ]
Fisheries_NutrientExtraction$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
Fisheries_NutrientExtraction$C_extracted_median <- quantiles_CIs_C[3, ]
Fisheries_NutrientExtraction$C_extracted_highIQR <- quantiles_CIs_C[4, ]
Fisheries_NutrientExtraction$C_extracted_highCI <- quantiles_CIs_C[5, ]

# Nitrogen
Fisheries_NutrientExtraction$N_extracted <- apply(N_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$N_extracted_SD <- apply(N_extractions, 1, FUN = sd)
quantiles_CIs_N <- apply(N_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$N_extracted_lowCI <- quantiles_CIs_N[1, ]
Fisheries_NutrientExtraction$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
Fisheries_NutrientExtraction$N_extracted_median <- quantiles_CIs_N[3, ]
Fisheries_NutrientExtraction$N_extracted_highIQR <- quantiles_CIs_N[4, ]
Fisheries_NutrientExtraction$N_extracted_highCI <- quantiles_CIs_N[5, ]

# Phosphorus
Fisheries_NutrientExtraction$P_extracted <- apply(P_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$P_extracted_SD <- apply(P_extractions, 1, FUN = sd)
quantiles_CIs_P <- apply(P_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$P_extracted_lowCI <- quantiles_CIs_P[1, ]
Fisheries_NutrientExtraction$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
Fisheries_NutrientExtraction$P_extracted_median <- quantiles_CIs_P[3, ]
Fisheries_NutrientExtraction$P_extracted_highIQR <- quantiles_CIs_P[4, ]
Fisheries_NutrientExtraction$P_extracted_highCI <- quantiles_CIs_P[5, ]



#### ESTIMATING NUTRIENT EXTRACTIONS BY CATEGORIES ####

##### YEAR #####
Nutrient_extractions_perYear <- data.frame(year = 1950:2018)

C_extractions_perYear <- C_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum)) # the 'starts_with("V)' piece is to summarize across the columns that have the simulated values from the matrix.

N_extractions_perYear <- N_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum))

P_extractions_perYear <- P_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum)) 

Nutrient_extractions_perYear <- C_extractions_perYear %>%
  rowwise() %>%
  mutate(
    C_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    C_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_C = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_C, names_sep = "_") %>%
  rename(
    C_extracted_lowCI = quantiles_CIs_C_1,
    C_extracted_lowIQR = quantiles_CIs_C_2,
    C_extracted_median = quantiles_CIs_C_3,
    C_extracted_highIQR = quantiles_CIs_C_4,
    C_extracted_highCI = quantiles_CIs_C_5
  ) %>%
  select(year, everything())

N_extractions_perYear <- N_extractions_perYear %>%
  rowwise() %>%
  mutate(
    N_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    N_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_N = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_N, names_sep = "_") %>%
  rename(
    N_extracted_lowCI = quantiles_CIs_N_1,
    N_extracted_lowIQR = quantiles_CIs_N_2,
    N_extracted_median = quantiles_CIs_N_3,
    N_extracted_highIQR = quantiles_CIs_N_4,
    N_extracted_highCI = quantiles_CIs_N_5
  )

P_extractions_perYear <- P_extractions_perYear %>%
  rowwise() %>%
  mutate(
    P_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    P_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_P = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_P, names_sep = "_") %>%
  rename(
    P_extracted_lowCI = quantiles_CIs_P_1,
    P_extracted_lowIQR = quantiles_CIs_P_2,
    P_extracted_median = quantiles_CIs_P_3,
    P_extracted_highIQR = quantiles_CIs_P_4,
    P_extracted_highCI = quantiles_CIs_P_5
  )

NutrientExtraction_perYear <- Nutrient_extractions_perYear %>%
  full_join(N_extractions_perYear, by = "year") %>%
  full_join(P_extractions_perYear, by = "year") %>%
  select(year, starts_with("C_"), starts_with("N_"), starts_with("P_"))





##### TIME PERIODS #####

C_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)

N_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)

P_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)



###### 1950-1954 ######
# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[1, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod <- as.data.frame(c("1950_54", "1993_97", "2014_18"))
colnames(NutrientExtraction_perTimePeriod)[1] <- "time_period"
NutrientExtraction_perTimePeriod$C_extracted <- NA
NutrientExtraction_perTimePeriod$C_extracted_SD <- NA
NutrientExtraction_perTimePeriod$C_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$C_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$C_extracted_median <- NA
NutrientExtraction_perTimePeriod$C_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$C_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$C_extracted <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

# cleanup
remove(quantiles_CIs_C)

# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[1, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod$N_extracted <- NA
NutrientExtraction_perTimePeriod$N_extracted_SD <- NA
NutrientExtraction_perTimePeriod$N_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$N_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$N_extracted_median <- NA
NutrientExtraction_perTimePeriod$N_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$N_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$N_extracted <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$N_extracted_SD <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)


# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[1, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod$P_extracted <- NA
NutrientExtraction_perTimePeriod$P_extracted_SD <- NA
NutrientExtraction_perTimePeriod$P_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$P_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$P_extracted_median <- NA
NutrientExtraction_perTimePeriod$P_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$P_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$P_extracted <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$P_extracted_SD <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)




###### 1993-1997 ######

# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[2, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$C_extracted <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

remove(quantiles_CIs_C)

# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[2, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$N_extracted <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$N_extracted_SD <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)

# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[2, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$P_extracted <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$P_extracted_SD <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)



###### 2014-2018 ######

# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[3, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$C_extracted <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

remove(quantiles_CIs_C)


# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[3, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$N_extracted <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$N_extracted_SD <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)


# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[3, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$P_extracted <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$P_extracted_SD <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)




##### FUNCTIONAL GROUPS #####



