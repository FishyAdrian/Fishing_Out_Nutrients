###############################################################################
#                                                                             #
#                           Fishing Out Nutrients                             #
#                             Data Analyses Code                              #
#                                                                             #
###############################################################################


#### NECESSARY PACKAGES ####
library(tidyverse)
library(data.table)
library(ggplot2)
library(GGally)
library(nlme)
library (MuMIn)
library(ggpubr)
library(mvtnorm)

# testing new edits to github


#### PREDICTIVE MODELS FOR NUTRIENT COMPOSITION ####

# The following function is used to generate the linear mixed-effects model we used for our nutrient ratios. We generated a model for each nutrient ratio (C:N, C:P, N:P). Ratio and nutrient must be indicated in quotes. E.g., ratio = "C_N"; nutrient = "N".

ratio_model <- function(data, ratio = NULL, nutrient = NULL) {
  
  ctrl <- lmeControl(opt = "optim", maxIter = 2000, msMaxIter = 2000, msMaxEval = 2000) # Specify model control values
  
  # Construct the formula. Nutrient ratios were log-transormed to normalize values.
  formula <- as.formula(paste("log(", ratio, ") ~", nutrient, "* V.I."))
  random_formula <- as.formula(paste("~ 1 +", nutrient, "| family/genus"))
  
  # Fit the model
  model <- lme(eval(substitute(formula)), 
               random = eval(substitute(random_formula)),
               method = "REML", 
               data = data, 
               na.action = na.exclude, 
               control = ctrl)
  
  return(model)
}

# The function can be used to generate a model predicting nutrient ratios from a specified nutrient.
ratio_lme <- ratio_model(data, ratio = NULL, nutrient = NULL)




#### NUTRIENT RATIO PREDICTIONS ####

# After the model is generated, we used the following code to generate predicted nutrient ratios based on observed nutrient compositions and the random effects generated by our model. The code has been reproduced as a function here. 

test_df <- pred_Ratios %>% select(c(1:23))

predict_ratios <- function(data, ratio_lme, nutrient = NULL) {
  
  # Extract fixed effect coefficients from model
  fixed_cf <- ratio_lme$coefficients$fixed
  
  
  # Combine the random effects from the family and genus levels. The random effects reported for the genus level are additive to those reported for the corresponding family level.
  genus_rf <- setDT(ranef(ratio_lme)$genus, keep.rownames = "Genus")
  family_rf <- setDT(ranef(ratio_lme)$family, keep.rownames = "Family")
  genus_rf <- genus_rf %>% separate(Genus, c("Family", "Genus"))
  genus_rf <- merge(genus_rf, family_rf,
                    by = ("Family"), all.x = TRUE)
  genus_rf$Intercept_rf <- genus_rf[ , 3] + genus_rf[ , 5]
  genus_rf$Slope_rf <- genus_rf[ , 4] + genus_rf[ , 6]
  genus_rf <- genus_rf[ , c(2, 7, 8)]
  genus_rf <- genus_rf %>% remove_rownames %>% column_to_rownames(var="Genus")
  family_rf <- ranef(ratio_lme)$family
  
  # Extract the standard deviations for the intercept and slope as well as the correlation between the two random effects
  SD_Cor_genus <- intervals(ratio_lme, level = 0.95, which = "all")$reStruct$genus[ , 2]
  SD_Cor_fam <- intervals(ratio_lme, level = 0.95, which = "all")$reStruct$family[ , 2]
  
  # Produce the variance-covariance matrices for the corresponding model
  vcv_fam <- matrix(c(SD_Cor_fam[1]^2, prod(SD_Cor_fam),
                      prod(SD_Cor_fam), SD_Cor_fam[2]^2), 
                    nrow = 2, ncol = 2, byrow = TRUE)
  vcv_genus <- matrix(c(SD_Cor_genus[1]^2, prod(SD_Cor_genus),
                        prod(SD_Cor_genus), SD_Cor_genus[2]^2), 
                      nrow = 2, ncol = 2, byrow = TRUE)  
  
  # Produce a random normal distribution based on the random effects. This will be drawn on for population-level predictions below. This accounts for the observed variation across the random-effect groups.
  rf_dist_fam <- rmvnorm(10000, sigma = vcv_fam)
  rf_dist_genus <- rmvnorm(10000, sigma = vcv_genus)
  
  
  # Create the columns within the data frame to hold predicted ratio values. 
  data$pred_ratio <-  NA
  data$pred_ratio_SD <- NA
  
  for (i in 1:nrow(data)) {
    # The `ifelse` bracket tells the for loop to use the the actual measured random effect for a group (either genus or family). If a random effect is not available for a group but the necessary input data is, then the for loop will draw a random effect from the simulated normal distribution of the random effects (rf_dist)
    if (data$genus[i] %in% rownames(genus_rf)) {
      rf_use = genus_rf[which(rownames(genus_rf) == data$genus[i]), ]
    }
    else{
      if (data$family[i] %in% rownames(family_rf)) {
        rf_use = family_rf[which(rownames(family_rf) == data$family[i]), ]
      }
      else{rf_use = rf_dist_fam + rf_dist_genus}} 
    
    nutrient_value <- data[[nutrient]][i]
    
    # Generate a vector of 10,000 predicted ratio values that incorporate parameter uncertainty, random effects, and residual error.
    pred <- (fixed_cf[1] + rf_use[, 1]) + 
      ((fixed_cf[2] + rf_use[, 2]) * nutrient_value) + 
      (fixed_cf[3] * data$V.I.numeric[i]) + 
      (fixed_cf[4] * nutrient_value * data$V.I.numeric[i]) + 
      rnorm(10000, mean = 0, sd = summary(ratio_lme)$sigma) #Pulls standard deviation value from model residuals.
    
    # Generates the predicted value and its corresponding standard deviation. exp() back-transforms values from log-space.
    data$pred_ratio[i] = mean(exp(pred))
    data$pred_ratio_SD[i] = sd(exp(pred))
  }
  
  return(data)
  
}

# The function, when used, generates a data frame with the predicted nutrient ratio values based on the composition of one of the nutrients (e.g., C:N predicted by N composition).
pred_ratios_df <- predict_ratios(data, ratio_lme, nutrient = NULL)




#### NUTRIENT COMPOSITION PREDICTIONS FROM PREDICTED RATIOS ###

# From the new data frame of predicted nutrient ratios, we used the following code to predict missing nutrient compositions. The code has been reproduced as three functions here. Each function predicts the corresponding nutrient. In this function, you indicate the data frame (data), the nutrient column that will be used as the predictor (nutrient), and the column within the data frame containing the predicted nutrient ratio value (pred_ratio) and its standard deviation (pred_ratio_SD).

# Carbon predition function
predict_C <- function(data, nutrient = NULL, pred_ratio = NULL, pred_ratio_SD = NULL) {
  
  # Creates columns for predicted nutrient values and their standard deviations.
  data$pred_nutrient = NA
  data$pred_nutrient_SD = NA
  
  if (!is.na(pred_ratio)) {
 
    if(nutrient == "N") {
  
      for (i in 1:nrow(data)) {
    
        # Assigns the value for the predicted nutrient ratio.
        ratio_value <- data[[pred_ratio]][i]
        ratio_value_SD <- data[[pred_ratio_SD]][i]
    
        
        ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (12/14)
        
        # Assigns the value for the nutrient being used to predict the missing composition.
        nutrient_value <- data[[nutrient]][i]
        
        # Calculates predicted nutrient composition 
        nutrient_dist = nutrient_value * ratio_dist
        
        # Generates the predicted nutrient composition and its corresponding standard deviation.
        data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
        data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
    
    } else if (nutrient == "P") {
      
      for (i in 1:nrow(data)) {
      
      # Assigns the value for the predicted nutrient ratio.
      ratio_value <- data[[pred_ratio]][i]
      ratio_value_SD <- data[[pred_ratio_SD]][i]
      
      
      ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (12/31)
      
      # Assigns the value for the nutrient being used to predict the missing composition.
      nutrient_value <- data[[nutrient]][i]
      
      # Calculates predicted nutrient composition 
      nutrient_dist = nutrient_value * ratio_dist
      
      # Generates the predicted nutrient composition and its corresponding standard deviation.
      data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
      data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
      
    } else {
      warning("Nutrient must be either 'N' or 'P'")
    }
    
  } else {NA}
  
  return(data)
   
}



# Nitrogen prediction function
predict_N <- function(data, nutrient = NULL, pred_ratio = NULL, pred_ratio_SD = NULL) {
  
  # Creates columns for predicted nutrient values and their standard deviations.
  data$pred_nutrient = NA
  data$pred_nutrient_SD = NA
  
  if (!is.na(pred_ratio)) {
    
    if(nutrient == "C") {
      
      for (i in 1:nrow(data)) {
        
        # Assigns the value for the predicted nutrient ratio.
        ratio_value <- data[[pred_ratio]][i]
        ratio_value_SD <- data[[pred_ratio_SD]][i]
        
        
        ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (14/12)
        
        # Assigns the value for the nutrient being used to predict the missing composition.
        nutrient_value <- data[[nutrient]][i]
        
        # Calculates predicted nutrient composition 
        nutrient_dist = nutrient_value * ratio_dist
        
        # Generates the predicted nutrient composition and its corresponding standard deviation.
        data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
        data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
      
    } else if (nutrient == "P") {
      
      for (i in 1:nrow(data)) {
        
        # Assigns the value for the predicted nutrient ratio.
        ratio_value <- data[[pred_ratio]][i]
        ratio_value_SD <- data[[pred_ratio_SD]][i]
        
        
        ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (14/31)
        
        # Assigns the value for the nutrient being used to predict the missing composition.
        nutrient_value <- data[[nutrient]][i]
        
        # Calculates predicted nutrient composition 
        nutrient_dist = nutrient_value * ratio_dist
        
        # Generates the predicted nutrient composition and its corresponding standard deviation.
        data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
        data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
      
    } else {
      warning("Nutrient must be either 'C' or 'P'")
    }
    
  } else {NA}
  
  return(data)
  
}



# Phosphorus prediction function
predict_P <- function(data, nutrient = NULL, pred_ratio = NULL, pred_ratio_SD = NULL) {
  
  # Creates columns for predicted nutrient values and their standard deviations.
  data$pred_nutrient = NA
  data$pred_nutrient_SD = NA
  
  if (!is.na(pred_ratio)) {
    
    if(nutrient == "C") {
      
      for (i in 1:nrow(data)) {
        
        # Assigns the value for the predicted nutrient ratio.
        ratio_value <- data[[pred_ratio]][i]
        ratio_value_SD <- data[[pred_ratio_SD]][i]
        
        
        ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (31/12)
        
        # Assigns the value for the nutrient being used to predict the missing composition.
        nutrient_value <- data[[nutrient]][i]
        
        # Calculates predicted nutrient composition 
        nutrient_dist = nutrient_value * ratio_dist
        
        # Generates the predicted nutrient composition and its corresponding standard deviation.
        data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
        data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
      
    } else if (nutrient == "N") {
      
      for (i in 1:nrow(data)) {
        
        # Assigns the value for the predicted nutrient ratio.
        ratio_value <- data[[pred_ratio]][i]
        ratio_value_SD <- data[[pred_ratio_SD]][i]
        
        
        ratio_dist = (rnorm(10000, mean = ratio_value, sd = ratio_value_SD)) * (31/14)
        
        # Assigns the value for the nutrient being used to predict the missing composition.
        nutrient_value <- data[[nutrient]][i]
        
        # Calculates predicted nutrient composition 
        nutrient_dist = nutrient_value * ratio_dist
        
        # Generates the predicted nutrient composition and its corresponding standard deviation.
        data$pred_nutrient[i] = mean(nutrient_dist, na.rm = TRUE)
        data$pred_nutrient_SD[i] = sd(nutrient_dist, na.rm = TRUE)
      }
      
    } else {
      warning("Nutrient must be either 'C' or 'N'")
    }
    
  } else {NA}
  
  return(data)
  
}



#### NUTRIENT COMPOSITIONS FOR HIGHER-LEVEL GROUPS AND DATA-SPARSE SPECIES ####

# After we generated predicted nutrient compositions using the predicted ratios and simulations described above, we averaged our observed and predicted nutrient data at the species level to generate C, N, and P compositions. To reduce the influence of over-represented species in our calculations, we first calculated the mean and standard deviations of nutrient composition values for each species represented in our dataset. Then, for each taxonomic level above species, we calculated the mean and standard deviation of nutrient composition values based on each taxonomic level's corresponding species. To account for compounding uncertainty among our observed and predicted values, we calculated the compounded standard deviation as described by the compound_SD equation below. NOTE: For observed values, we did not record SDs since these were not always reported. However, to account for uncertainty in observed nutrient values, we assigned SDs based on the in-species coefficients of variation (CV) for each nutrient observed in Czamanski et al. (2011) (https://link.springer.com/article/10.1007/s00227-011-1783-7). The coefficients of variation for each nutrient were as follows: CV of C = 0.0175, CV of N = 0.0097, and CV of P = 0.0528. This assured that each observed and predicted value had an associated SD to be used in calculating the compound standard deviation.

# In the following function, data is used to designate the data frame that has all of your observed and predicted values. Level designates the taxonomic level you are attempting to average. Nutrient and "nutrient_SD" designates the columns that hold your nutrient values and their corresponding SDs, respectively.

nutrient_mean_SD <- function(data, level = NULL, nutrient = NULL, nutrient_SD = NULL) {
  
  level <- enquo(level)
  nutrient <- enquo(nutrient)
  nutrient_SD <- enquo(nutrient_SD)
  
  # Ensure that nutrient and nutrient_SD are provided
  if (is.null(level) || is.null(nutrient) || is.null(nutrient_SD)) {
    stop("Please specify level, nutrient, and nutrient_SD columns.")
  }
  
  mean_nutrient_df <- data %>% 
    group_by(!!level) %>% 
    summarise(mean_nutrient = mean(!!nutrient, na.rm = TRUE),
              # The following calculates the compound standard deviation across values for a nutrient.
              compound_SD = sqrt(sum((!!nutrient_SD^2 + 
                                        (!!nutrient - mean(!!nutrient, na.rm = TRUE))^2), 
                                     na.rm = TRUE) / n()),
              .groups = 'drop')
  
  return(mean_nutrient_df)
}



#### ASSIGNING NUTRIENT COMPOSITION VALUES FOR SPECIES AND GROUPS WITHOUT DATA ####

# Explanation here...

# Function to fill missing nutrient content based on taxonomic hierarchy
assign_nutrient_value <- function(data, taxonomic_levels, nutrient_col = NULL, sd_col = NULL) {
  
  for (i in 1:nrow(data)) {
    if (is.na(data[[nutrient_col]][i])) {
      for (level in taxonomic_levels) {
        taxon <- data[[level]][i]
        # Check if there is a non-NA nutrient value for the taxon in the same data frame
        matching_row <- data[!is.na(data[[nutrient_col]]) & data[[level]] == taxon, ]
        if (nrow(matching_row) > 0) {
          data[[nutrient_col]][i] <- matching_row[[nutrient_col]][1] # Assign the first matching value
          data[[sd_col]][i] <- matching_row[[sd_col]][1] # Assign the first matching SD value
          break
        }
      }
    }
  }
  
  return(data)
}
  

# You can assign the taxonomic levels you desire to draw averages from by assigning the levels to a vector like so:
taxonomic_levels <- c("genus", "family", "order", "super_order", "class", "super_class", "sub_phylum", "phylum")
  
  
  
  
  

#### ESTIMATING NUTRIENT EXTRACTIONS ####

# To account for uncertainties around producing nutrient extraction estimates, we generated 100 nutrient values drawn from a random normal distribution of each taxa's mean nutrient compositions for each row of the SAU dataset. The SAU data comprised 6.7+ million rows of data where each row of data had a distribution of 100 nutrient composition values for the row's corresponding taxa.

# We wanted to make sure we could generate distributions that were between 0 and 100. Since some of our values are very close to 0 (especially in the case of phosphorus), we wanted to ensure that no negative values were accidentally generated during our random draws. To accomplish this, we transformed our nutrient compositions into alpha and beta values so we could generate beta distributions. The transformations we made are recreated below.

taxa_nutrient.data <- taxa_nutrient.data %>% 
  mutate(alph_C = (mean_C/100)*(((mean_C/100)*(1- (mean_C/100)))/((SD_C/100)^2)-1),
         bet_C = (1-(mean_C/100))*(((mean_C/100)*(1- (mean_C/100)))/((SD_C/100)^2)-1),
         alph_N = (mean_N/100)*(((mean_N/100)*(1- (mean_N/100)))/((SD_N/100)^2)-1),
         bet_N = (1-(mean_N/100))*(((mean_N/100)*(1- (mean_N/100)))/((SD_N/100)^2)-1),
         alph_P = (mean_P/100)*(((mean_P/100)*(1- (mean_P/100)))/((SD_P/100)^2)-1),
         bet_P = (1-(mean_P/100))*(((mean_P/100)*(1- (mean_P/100)))/((SD_P/100)^2)-1))


# The following code created a vector of integers to identify which rows of the nutrient composition data frame had to be called when calculating nutrient extraction with the fisheries data frame. TaxonKey is a unique ID code for each taxa. These ID codes were provided by the SAU and used to match taxa between our nutrient composition data frame and the catch data frame.
taxaorder <- match(taxa_nutrient.data$TaxonKey, SAU_catch.data$TaxonKey)


# Then, using the newly transformed values, we generated 100 nutrient composition values taken from beta distributions. Here, we generated a matrix where each row of the fisheries dataset had a distribution of 100 nutrient values based on the corresponding taxa for each row. Each of the 100 generate values were then multiplied by the landed amount reported in the fisheries dataset. The code used to generate these matrices is reproduced below.

C_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_C[taxaorder], 
        taxa_nutrient.data$bet_C[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

N_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_N[taxaorder], 
        taxa_nutrient.data$bet_N[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

P_distributions <- matrix(
  rbeta(length(taxaorder) * 100, taxa_nutrient.data$alph_P[taxaorder], 
        taxa_nutrient.data$bet_P[taxaorder]), 
  nrow = length(taxaorder), ncol = 100
)

# Then, we multiplied the matrix of the generated values by the landed amount (tonnes) to generate a distribution of 100 estimates of nutrient extractions. We used the Sea Around Us data (https://www.seaaroundus.org/data/) at the EEZ and High Seas level meaning we download the CSV data files for each EEZ (n=283) and High Seas region (n=18) and compiled all of the data into one data frame that comprised 6.7+ million records of landed catches (reported in tonnes in the SAU data).

C_extractions <- SAU_catch.data$tonnes * C_distributions
N_extractions <- SAU_catch.data$tonnes * N_distributions
P_extractions <- SAU_catch.data$tonnes * P_distributions


# Finally, we took C_extracted to be the mean of the 100 extraction estimates produced above. We also obtained the SD, IQR, and 95% CIs. The 'Fisheries_NutrientExtraction' represents our finalized data frame which had all the estimates of C, N, and P extraction per row of the fisheries record (n=)

# Carbon
Fisheries_NutrientExtraction$C_extracted <- apply(C_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$C_extracted_SD <- apply(C_extractions, 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$C_extracted_lowCI <- quantiles_CIs_C[1, ]
Fisheries_NutrientExtraction$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
Fisheries_NutrientExtraction$C_extracted_median <- quantiles_CIs_C[3, ]
Fisheries_NutrientExtraction$C_extracted_highIQR <- quantiles_CIs_C[4, ]
Fisheries_NutrientExtraction$C_extracted_highCI <- quantiles_CIs_C[5, ]

# Nitrogen
Fisheries_NutrientExtraction$N_extracted <- apply(N_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$N_extracted_SD <- apply(N_extractions, 1, FUN = sd)
quantiles_CIs_N <- apply(N_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$N_extracted_lowCI <- quantiles_CIs_N[1, ]
Fisheries_NutrientExtraction$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
Fisheries_NutrientExtraction$N_extracted_median <- quantiles_CIs_N[3, ]
Fisheries_NutrientExtraction$N_extracted_highIQR <- quantiles_CIs_N[4, ]
Fisheries_NutrientExtraction$N_extracted_highCI <- quantiles_CIs_N[5, ]

# Phosphorus
Fisheries_NutrientExtraction$P_extracted <- apply(P_extractions, 1, FUN = mean)
Fisheries_NutrientExtraction$P_extracted_SD <- apply(P_extractions, 1, FUN = sd)
quantiles_CIs_P <- apply(P_extractions, 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
Fisheries_NutrientExtraction$P_extracted_lowCI <- quantiles_CIs_P[1, ]
Fisheries_NutrientExtraction$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
Fisheries_NutrientExtraction$P_extracted_median <- quantiles_CIs_P[3, ]
Fisheries_NutrientExtraction$P_extracted_highIQR <- quantiles_CIs_P[4, ]
Fisheries_NutrientExtraction$P_extracted_highCI <- quantiles_CIs_P[5, ]



#### ESTIMATING NUTRIENT EXTRACTIONS BY CATEGORIES ####

##### YEAR #####
Nutrient_extractions_perYear <- data.frame(year = 1950:2018)

C_extractions_perYear <- C_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum)) # the 'starts_with("V)' piece is to summarize across the columns that have the simulated values from the matrix.

N_extractions_perYear <- N_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum))

P_extractions_perYear <- P_extractions %>%
  as.data.frame() %>%
  bind_cols(year = Fisheries_NutrientExtraction$year) %>%
  group_by(year) %>%
  summarise(across(starts_with("V"), sum)) 

Nutrient_extractions_perYear <- C_extractions_perYear %>%
  rowwise() %>%
  mutate(
    C_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    C_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_C = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_C, names_sep = "_") %>%
  rename(
    C_extracted_lowCI = quantiles_CIs_C_1,
    C_extracted_lowIQR = quantiles_CIs_C_2,
    C_extracted_median = quantiles_CIs_C_3,
    C_extracted_highIQR = quantiles_CIs_C_4,
    C_extracted_highCI = quantiles_CIs_C_5
  ) %>%
  select(year, everything())

N_extractions_perYear <- N_extractions_perYear %>%
  rowwise() %>%
  mutate(
    N_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    N_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_N = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_N, names_sep = "_") %>%
  rename(
    N_extracted_lowCI = quantiles_CIs_N_1,
    N_extracted_lowIQR = quantiles_CIs_N_2,
    N_extracted_median = quantiles_CIs_N_3,
    N_extracted_highIQR = quantiles_CIs_N_4,
    N_extracted_highCI = quantiles_CIs_N_5
  )

P_extractions_perYear <- P_extractions_perYear %>%
  rowwise() %>%
  mutate(
    P_extracted = mean(c_across(starts_with("V")), na.rm = TRUE),
    P_extracted_SD = sd(c_across(starts_with("V")), na.rm = TRUE),
    quantiles_CIs_P = list(quantile(c_across(starts_with("V")), probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE))
  ) %>%
  unnest_wider(quantiles_CIs_P, names_sep = "_") %>%
  rename(
    P_extracted_lowCI = quantiles_CIs_P_1,
    P_extracted_lowIQR = quantiles_CIs_P_2,
    P_extracted_median = quantiles_CIs_P_3,
    P_extracted_highIQR = quantiles_CIs_P_4,
    P_extracted_highCI = quantiles_CIs_P_5
  )

NutrientExtraction_perYear <- Nutrient_extractions_perYear %>%
  full_join(N_extractions_perYear, by = "year") %>%
  full_join(P_extractions_perYear, by = "year") %>%
  select(year, starts_with("C_"), starts_with("N_"), starts_with("P_"))





##### TIME PERIODS #####

C_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)

N_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)

P_extractions_per_timeperiod <- data.frame(
  time_period = c("1950_54", "1993_97", "2014_18"),
  stringsAsFactors = FALSE
)



###### 1950-1954 ######
# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[1, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod <- as.data.frame(c("1950_54", "1993_97", "2014_18"))
colnames(NutrientExtraction_perTimePeriod)[1] <- "time_period"
NutrientExtraction_perTimePeriod$C_extracted <- NA
NutrientExtraction_perTimePeriod$C_extracted_SD <- NA
NutrientExtraction_perTimePeriod$C_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$C_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$C_extracted_median <- NA
NutrientExtraction_perTimePeriod$C_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$C_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$C_extracted <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[1, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

# cleanup
remove(quantiles_CIs_C)

# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[1, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod$N_extracted <- NA
NutrientExtraction_perTimePeriod$N_extracted_SD <- NA
NutrientExtraction_perTimePeriod$N_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$N_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$N_extracted_median <- NA
NutrientExtraction_perTimePeriod$N_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$N_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$N_extracted <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$N_extracted_SD <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[1, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)


# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[1, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(1950:1954))])
  
}

NutrientExtraction_perTimePeriod$P_extracted <- NA
NutrientExtraction_perTimePeriod$P_extracted_SD <- NA
NutrientExtraction_perTimePeriod$P_extracted_lowCI <- NA
NutrientExtraction_perTimePeriod$P_extracted_lowIQR <- NA
NutrientExtraction_perTimePeriod$P_extracted_median <- NA
NutrientExtraction_perTimePeriod$P_extracted_highIQR <- NA
NutrientExtraction_perTimePeriod$P_extracted_highCI <- NA


NutrientExtraction_perTimePeriod[1, ]$P_extracted <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[1, ]$P_extracted_SD <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[1 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[1, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[1, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)




###### 1993-1997 ######

# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[2, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$C_extracted <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[2, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

remove(quantiles_CIs_C)

# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[2, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$N_extracted <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$N_extracted_SD <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[2, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)

# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[2, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(1993:1997))])
  
}

NutrientExtraction_perTimePeriod[2, ]$P_extracted <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[2, ]$P_extracted_SD <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[2 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[2, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[2, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)



###### 2014-2018 ######

# Carbon
for (A in 1:nrow(C_extractions_per_timeperiod)) {
  
  C_extractions_per_timeperiod[3, 2:101] <- colSums(C_extractions[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$C_extracted <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$C_extracted_SD <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_C <- apply(C_extractions_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$C_extracted_lowCI <- quantiles_CIs_C[1, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_lowIQR <- quantiles_CIs_C[2, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_median <- quantiles_CIs_C[3, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_highIQR <- quantiles_CIs_C[4, ]
NutrientExtraction_perTimePeriod[3, ]$C_extracted_highCI <- quantiles_CIs_C[5, ]

remove(quantiles_CIs_C)


# Nitrogen
for (A in 1:nrow(N_out_per_timeperiod)) {
  
  N_out_per_timeperiod[3, 2:101] <- colSums(N_out[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$N_extracted <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$N_extracted_SD <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_N <- apply(N_out_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$N_extracted_lowCI <- quantiles_CIs_N[1, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_lowIQR <- quantiles_CIs_N[2, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_median <- quantiles_CIs_N[3, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_highIQR <- quantiles_CIs_N[4, ]
NutrientExtraction_perTimePeriod[3, ]$N_extracted_highCI <- quantiles_CIs_N[5, ]

remove(quantiles_CIs_N)


# Phosphorus
for (A in 1:nrow(P_out_per_timeperiod)) {
  
  P_out_per_timeperiod[3, 2:101] <- colSums(P_out[which(Fisheries_NutrientExtraction$year %in% c(2014:2018))])
  
}

NutrientExtraction_perTimePeriod[3, ]$P_extracted <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = mean)
NutrientExtraction_perTimePeriod[3, ]$P_extracted_SD <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = sd)
quantiles_CIs_P <- apply(P_out_per_timeperiod[3 , 2:101], 1, FUN = quantile, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
NutrientExtraction_perTimePeriod[3, ]$P_extracted_lowCI <- quantiles_CIs_P[1, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_lowIQR <- quantiles_CIs_P[2, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_median <- quantiles_CIs_P[3, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_highIQR <- quantiles_CIs_P[4, ]
NutrientExtraction_perTimePeriod[3, ]$P_extracted_highCI <- quantiles_CIs_P[5, ]

remove(quantiles_CIs_P)




##### FUNCTIONAL GROUPS #####



